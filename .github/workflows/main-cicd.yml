name: Build & Deploy to EKS (main)

on:
  push:
    branches: [ main ]
  workflow_dispatch: {}

jobs:
  build-push-deploy:
    runs-on: self-hosted

    env:
      # from GitHub Variables
      AWS_REGION: ${{ vars.AWS_REGION }}
      EKS_CLUSTER_NAME: ${{ vars.EKS_CLUSTER_NAME }}
      K8S_NAMESPACE: ${{ vars.K8S_NAMESPACE }}
      ECR_ACCOUNT_ID: ${{ vars.ECR_ACCOUNT_ID }}
      ECR_REGISTRY: ${{ vars.ECR_REGISTRY }}
      IMAGE_TAG: ${{ github.sha }}

      # Secrets Manager
      RDS_SECRET_NAME: ${{ vars.RDS_SECRET_NAME }}

      # Mongo config (from GitHub Variables)
      MONGO_URI: ${{ vars.MONGO_URI }}
      MONGO_DB: ${{ vars.MONGO_DB }}
      MONGO_PRODUCTS_COLLECTION: ${{ vars.MONGO_PRODUCTS_COLLECTION }}


      # Redis config
      REDIS_URL: ${{ vars.REDIS_URL }}

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Show AWS identity (sanity check)
        run: aws sts get-caller-identity

      - name: Login to ECR
        run: |
          aws ecr get-login-password --region "$AWS_REGION" \
            | docker login --username AWS --password-stdin "$ECR_REGISTRY"

      # ========= BUILD & PUSH IMAGES =========

      - name: Build & push products service
        run: |
          cd ecommerce-eks
          IMAGE="$ECR_REGISTRY/ecommerce-products:$IMAGE_TAG"
          docker build -t "$IMAGE" services/products
          docker push "$IMAGE"

      - name: Build & push users service
        run: |
          cd ecommerce-eks
          IMAGE="$ECR_REGISTRY/ecommerce-users:$IMAGE_TAG"
          docker build -t "$IMAGE" services/users-java
          docker push "$IMAGE"

      - name: Build & push inventory service
        run: |
          cd ecommerce-eks
          IMAGE="$ECR_REGISTRY/ecommerce-inventory:$IMAGE_TAG"
          docker build -t "$IMAGE" services/inventory
          docker push "$IMAGE"

      - name: Build & push orders service
        run: |
          cd ecommerce-eks
          IMAGE="$ECR_REGISTRY/ecommerce-orders:$IMAGE_TAG"
          docker build -t "$IMAGE" services/orders-java
          docker push "$IMAGE"

      - name: Build & push payments service
        run: |
          cd ecommerce-eks
          IMAGE="$ECR_REGISTRY/ecommerce-payments:$IMAGE_TAG"
          docker build -t "$IMAGE" services/payments
          docker push "$IMAGE"

      - name: Build & push storefront service
        run: |
          cd ecommerce-eks
          IMAGE="$ECR_REGISTRY/ecommerce-storefront:$IMAGE_TAG"
          docker build -t "$IMAGE" services/storefront
          docker push "$IMAGE"

      # ========= SECURITY SCAN (TRIVY) =========
      - name: Scan images with Trivy (fail on CRITICAL/HIGH)
        run: |
          SERVICES=("products" "users" "inventory" "orders" "payments" "storefront")

          for svc in "${SERVICES[@]}"; do
            IMAGE="$ECR_REGISTRY/ecommerce-$svc:$IMAGE_TAG"
            echo "Scanning image: $IMAGE"

            docker run --rm \
              -v /var/run/docker.sock:/var/run/docker.sock \
              aquasec/trivy:latest \
              image \
                --severity CRITICAL \
                --exit-code 1 \
                --no-progress \
                "$IMAGE"
          done

      # ========= POLICY VALIDATION (KYVERNO) =========
      - name: Install Kyverno CLI
        run: |
          curl -L -o kyverno.tar.gz "https://github.com/kyverno/kyverno/releases/download/v1.16.1/kyverno-cli_v1.16.1_linux_x86_64.tar.gz"
          tar -xzf kyverno.tar.gz
          sudo mv kyverno /usr/local/bin/kyverno
          kyverno version

      # ========= VALIDATE MANIFESTS WITH KYVERNO =========

      - name: Validate Kubernetes manifests with Kyverno
        run: |
          cd ecommerce-eks
          # Policies live in: k8s/policies
          # Manifests (resources) live in: k8s/base
          kyverno apply k8s/policies -r k8s/base

      # ========= CONFIGURE KUBECTL =========

      - name: Configure kubectl for EKS
        run: |
          aws eks update-kubeconfig --region "$AWS_REGION" --name "$EKS_CLUSTER_NAME"
          kubectl get nodes

      # ========= APPLY DB CONFIGMAP + SECRET =========

      - name: Fetch DB config & credentials from AWS Secrets Manager
        run: |
          # 1) Get JSON from Secrets Manager
          SECRET_JSON=$(aws secretsmanager get-secret-value \
            --secret-id "$RDS_SECRET_NAME" \
            --query SecretString \
            --output text)

          # 2) Parse fields using jq
          if ! command -v jq >/dev/null 2>&1; then
            sudo yum install -y jq || sudo apt-get update && sudo apt-get install -y jq || true
          fi

          DB_HOST=$(echo "$SECRET_JSON"    | jq -r '.host')
          DB_NAME=$(echo "$SECRET_JSON"    | jq -r '.dbname')
          DB_USER=$(echo "$SECRET_JSON"    | jq -r '.username')
          DB_PASSWORD=$(echo "$SECRET_JSON"| jq -r '.password')

          echo "DB_HOST=$DB_HOST"       >> $GITHUB_ENV
          echo "DB_NAME=$DB_NAME"       >> $GITHUB_ENV
          echo "DB_USER=$DB_USER"       >> $GITHUB_ENV
          echo "DB_PASSWORD=$DB_PASSWORD" >> $GITHUB_ENV
          

      - name: Apply DB ConfigMap and Secret from Secrets Manager data
        run: |
          # ConfigMap for non-secret values
          kubectl -n "$K8S_NAMESPACE" create configmap shop-config \
            --from-literal=MYSQL_HOST="${DB_HOST}" \
            --from-literal=MYSQL_DB="${DB_NAME}" \
            --dry-run=client -o yaml | kubectl apply -f -

          # Secret for credentials
          kubectl -n "$K8S_NAMESPACE" create secret generic mysql-credentials \
            --from-literal=MYSQL_USER="${DB_USER}" \
            --from-literal=MYSQL_PASSWORD="${DB_PASSWORD}" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Apply Mongo ConfigMap (mongo-config)
        run: |
          kubectl -n "$K8S_NAMESPACE" create configmap mongo-config \
            --from-literal=MONGO_URI="${MONGO_URI}" \
            --from-literal=MONGO_DB="${MONGO_DB}" \
            --from-literal=MONGO_PRODUCTS_COLLECTION="${MONGO_PRODUCTS_COLLECTION}" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Apply Redis ConfigMap (redis-config)
        run: |
          kubectl -n "$K8S_NAMESPACE" create configmap redis-config \
            --from-literal=REDIS_URL="${REDIS_URL}" \
            --dry-run=client -o yaml | kubectl apply -f -

      # ========= DEPLOY / UPDATE IMAGES IN EKS =========

      - name: Update deployments with new images
        run: |
          kubectl -n "$K8S_NAMESPACE" set image deployment/products-deployment \
            products="$ECR_REGISTRY/ecommerce-products:$IMAGE_TAG"

          kubectl -n "$K8S_NAMESPACE" set image deployment/users-deployment \
            users="$ECR_REGISTRY/ecommerce-users:$IMAGE_TAG"

          kubectl -n "$K8S_NAMESPACE" set image deployment/inventory-deployment \
            inventory="$ECR_REGISTRY/ecommerce-inventory:$IMAGE_TAG"

          kubectl -n "$K8S_NAMESPACE" set image deployment/orders-deployment \
            orders="$ECR_REGISTRY/ecommerce-orders:$IMAGE_TAG"

          kubectl -n "$K8S_NAMESPACE" set image deployment/payments-deployment \
            payments="$ECR_REGISTRY/ecommerce-payments:$IMAGE_TAG"

          kubectl -n "$K8S_NAMESPACE" set image deployment/storefront-deployment \
            storefront="$ECR_REGISTRY/ecommerce-storefront:$IMAGE_TAG"

      - name: Wait for rollouts
        run: |
          kubectl -n "$K8S_NAMESPACE" rollout status deployment/products-deployment
          kubectl -n "$K8S_NAMESPACE" rollout status deployment/users-deployment
          kubectl -n "$K8S_NAMESPACE" rollout status deployment/inventory-deployment
          kubectl -n "$K8S_NAMESPACE" rollout status deployment/orders-deployment
          kubectl -n "$K8S_NAMESPACE" rollout status deployment/payments-deployment
          kubectl -n "$K8S_NAMESPACE" rollout status deployment/storefront-deployment